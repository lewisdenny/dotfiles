---cb must be called on done
---multiple result not supported, it will complicate things significantly
---in js Promise.all also don't support multiple result
---
local function await(future)
  local thread = assert(coroutine.running())
  local future_finished = false
  local future_result

  -- we need to handle two cases:
  -- 1. future callback will be executed right now
  -- 2. future callback will be executed later on event loop

  future(function(result)
    future_finished = true
    future_result = result
    if coroutine.status(thread) == "suspended" then
      coroutine.resume(thread)
    end
  end)

  -- Handles case 2
  if not future_finished then
    coroutine.yield()
  end

  return future_result
end

local function join(futures)
  return function(cb)
    local pending_count = #futures
    local results = {}
    for index, future in ipairs(futures) do
      future(function(result)
        results[index] = result
        pending_count = pending_count - 1
        if pending_count == 0 then
          cb(results)
        end
      end)
    end
  end
end

local function wait(ms)
  return function(cb)
    vim.defer_fn(cb, ms)
  end
end

coroutine.wrap(function()
  local future1 = await(wait(1000))
  local future2 = await(wait(1000))
  print("all futures done")
end)()
